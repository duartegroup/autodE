import autode.exceptions as ex
from autode.config import Config
from autode.log import logger
from autode.calculation import Calculation
from autode.neb.ci import CINEB
from autode.methods import get_lmethod
from autode.transition_states.ts_guess import get_ts_guess
from autode.utils import work_in
from autode.mol_graphs import find_cycles, is_isomorphic, make_graph
import numpy as np


def get_ts_guess_neb(reactant, product, method, fbonds=None, bbonds=None,
                     name='neb',
                     n=None,
                     generate_final_species=True):
    """
    Get a transition state guess using a nudged elastic band calculation. The
    geometry of the reactant is used as the fixed initial point and the final
    product geometry generated by driving a linear path to products, which is
    used as the initial guess for the NEB images

    Arguments:
        reactant (autode.species.Species):
        product (autode.species.Species):
        method (autode.wrappers.base.ElectronicStructureMethod):

    Keyword Arguments:
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):
        name (str):
        n (int): Number of images to use in the NEB
        generate_final_species (bool):

    Returns:
        (autode.transition_states.ts_guess.TSguess) or None:
    """
    logger.info('Generating a TS guess using a nudged elastic band')

    if generate_final_species and fbonds is not None and bbonds is not None:

        try:
            species_list = get_interpolated(reactant, fbonds, bbonds,
                                            max_n=calc_n_images(fbonds, bbonds),
                                            method=method,
                                            final_species=product)
        except ex.AtomsNotFound:
            logger.warning('Failed to optimise a point on the linear path')
            return None

        if species_list is None:
            logger.warning('Failed to locate linear path containing a maximum')
            return None

        neb = CINEB(species_list=species_list)
        if len(species_list) == 3:
            neb.partition(n=3)

    # Otherwise using the reactant and product geometries
    else:
        assert n is not None
        neb = CINEB(initial_species=reactant.copy(),
                    final_species=product.copy(),
                    num=n)
        neb.interpolate_geometries()

    # Calculate and generate the TS guess, in a unique directory
    try:
        @work_in(name)
        def calculate():
            return neb.calculate(method=method, n_cores=Config.n_cores)

        calculate()

    except (ex.CouldNotGetProperty, ex.AtomsNotFound):
        logger.error('NEB failed')
        return None

    peak_species = neb.get_species_saddle_point()
    if peak_species is None:
        logger.warning('Found no peak in the NEB')
        return None

    if fbonds is not None and bbonds is not None:
        run_final_const_opt(peak_species, method, const_bonds=fbonds+bbonds)

    return get_ts_guess(peak_species, reactant, product, name=name)


@work_in('NEB_init_path')
def get_interpolated(initial_species, fbonds, bbonds, max_n, method=None,
                     stop_thresh=0.02, final_species=None):
    """
    Generate the end point on the NEB by running a 1D scan, using by default a
    low-level method. Supprorts using different methods for the starting and
    final (end) points to the method used for the interpolation.
    If method is set then this will be used for both the end and intermediate
     methods

    Arguments:
        initial_species (autode.species.Species):
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):
        max_n (int): Maximum number of intermediate species to generate between
              the initial and final species

    Keyword Arguments:
        method (autode.wrappers.base.ElectronicStructureMethod):

        stop_thresh (float): Energy threshold in Ha to terminate the
                    interpolation if ∆E between two adjacent points is > this
                    and there is a peak in the surface, return the points.
                    default is ~ 10 kcal mol-1

        final_species (autode.species.Species | None): Final species (e.g.
                      products) on the path that we're interpolating to. If
                      None then isomorphisms are not checked

    Returns:
        (list(autode.species.Species)): Set of intermediate species between
    """
    assert fbonds is not None and bbonds is not None
    logger.info('Generating the interpolated species reactant -> product using'
                f' a maximum of {max_n} intermediate points')

    bonds = active_bonds_no_rings(initial_species, fbonds, bbonds)

    # Calculate the uniform change in each bond distance from initial -> final
    deltas = [(b.final_dist - b.curr_dist)/(max_n-1) for b in bonds]

    # Set a dictionary of bond length constraints
    consts = {b.atom_indexes: b.curr_dist for b in bonds}

    species_set = _get_interp_species_set(max_n, initial_species, consts,
                                          deltas, method, stop_thresh)

    # Needs to have a maximum in the linear path to have any hope of
    # locating a TS from it
    if peak_idx(species_set) is None:
        if not products_made(species_set, final_species):
            logger.warning('No peak and products not made')
            return None
        # If there is no peak but products have been made then reduce the step
        # size around the region reactants -> products
        species_set = divided_species_set(species_set, bonds,
                                          method=method,
                                          final_species=final_species)

        if peak_idx(species_set) is None:
            logger.warning('Still no peak from the divided path')
            return None

    # If the final point is higher in energy than the previous then remove
    # the last, then iterate as appropriate
    while len(species_set) >= 2 and species_set[-2].energy < species_set[-1].energy:
        species_set.pop(-1)

    # If only a one bond has been scanned over then the initial path is already
    # pretty good, so truncate to the two points either side of the peak,
    # and the peak
    if len(bonds) == 1:
        logger.info('Truncating interpolated set over the peak')
        idx = peak_idx(species_set)
        species_set = species_set[idx-1:idx+2]

    logger.info('Generated initial NEB path')
    return species_set


def divided_species_set(species_list, bonds, method, final_species=None, max_n=5):
    """
    Divide a list of species

    Arguments:
        species_list:
        bonds (list(autode.pes.pes.ScannedBond)):

        final_species (autode.species.Species | None): Final species (e.g.
                      products) on the path that we're interpolating to. If
                      None then isomorphisms are not checked    Returns:
    Returns:

    """
    if not products_made(species_list, final_species):
        logger.warning('Cannot divide species list to locate peak without '
                       'a final species/no products made to check isomorphisms')
        return None

    # Ensure all species have a graph
    for species in species_list:
        make_graph(species)

    def isomorphic_idxs(graph):
        """Return the indexes of the graphs isomorphic to the given"""
        return [i for i, species_ in enumerate(species_list)
                if is_isomorphic(graph1=species_.graph, graph2=graph)]

    # Use the final index that's isomorphic to the initial species (i.e. the
    # first point in the species list)
    idx_l = isomorphic_idxs(graph=species_list[0].graph)[-1]

    # and the right index the first that's isomorphic to the final species
    idx_r = isomorphic_idxs(graph=final_species.graph)[0]

    for bond in bonds:
        bond.curr_dist = species_list[idx_l].distance(*bond)
        bond.final_dist = species_list[idx_r].distance(*bond)

    deltas = [(b.final_dist - b.curr_dist) / (max_n - 1) for b in bonds]
    consts = {b.atom_indexes: b.curr_dist for b in bonds}

    species_list = _get_interp_species_set(max_n=max_n,
                                           initial_species=species_list[idx_l],
                                           consts=consts,
                                           deltas=deltas,
                                           stop_thresh=0.02,
                                           method=method)
    return species_list


def _get_interp_species_set(max_n, initial_species, consts, deltas, method,
                            stop_thresh):
    """
    From an initial species generate a path along a surface defined by
    distance constraints

    Arguments:
        initial_species (autode.species.Species):
        consts (dict): Keyed with tuples of atom indexes and values of the
                       initial distance
        deltas (list): ∆r distances for all the constraints
        max_n (int): Maximum number of intermediate species to generate
        method (autode.wrappers.base.ElectronicStructureMethod):
        stop_thresh (float):
    """
    species_set = []

    # Generate a species with a constrained geometry for each point in the path
    for i in range(max_n):

        if i == 0:
            species = initial_species.copy()

        else:
            species = species_set[i - 1].copy()

            # Add the required change in every bond length to get to the final
            # distances at step n-1
            for j, atom_indexes in enumerate(consts.keys()):
                consts[atom_indexes] += deltas[j]

        # Run the constrained optimisation
        if method is None:
            method = get_lmethod()

        opt = Calculation(name=f'{species.name}_constrained_opt{i}',
                          molecule=species,
                          method=method,
                          keywords=method.keywords.low_opt,
                          n_cores=Config.n_cores,
                          distance_constraints=consts)

        # Set the optimised atoms - can raise AtomsNotFound
        species.optimise(method=method, calc=opt)
        if species.energy is None:
            # To continue there must be final atoms and a final energy
            raise ex.AtomsNotFound

        species_set.append(species)

        # Early stopping if a ~saddle point has already been traversed, must be
        # in the second half of the scan and above an energy threshold for ∆E
        if all((i > 1,
                i > max_n // 2,
                peak_idx(species_set) is not None,
                species.energy - species_set[i - 1].energy > stop_thresh)):
            logger.warning(f'Path contained an energy peak and the point '
                           f'before this one had a lower energy - stopping the'
                           f' interpolation on step {i}')

            return species_set[:-1]

    return species_set


def active_bonds_no_rings(initial_species, fbonds, bbonds):
    """
    From forming and breaking bonds determine which should be used as the
    set of active bonds that define bond constraints. Any breaking bonds that
    form rings with forming bonds or those already in the graph should be
    removed to try and avoid very high energy points in the potential.
    For example:

               H
    forming-> / \  <-breaking
             C--C
               ^
               |
             normal

    by default the breaking bonds final distance will be the current x1.5 or so
    which will push the H too far away (as it's migrating rather than leaving).
    A much better strategy is to only scan the forming C-H bond and leave the
    breaking bond to do it's own thing.

    Arguments:
        initial_species (autode.species.Species):
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):

    Returns:
        (list(autode.pes.pes.ScannedBond)):
    """
    logger.info('Removing breaking bonds that are also in the set of forming '
                'bonds')

    if len(fbonds) == 0:
        logger.info('No need to check for rings, no forming bonds')
        return bbonds

    graph = initial_species.graph.copy()

    # Add all the active bonds if they don't already exist
    for bond in bbonds + fbonds:
        if bond.atom_indexes not in graph.edges:
            graph.add_edge(*bond.atom_indexes)

    # Find the rings in this molecular graph
    rings = find_cycles(graph)

    def in_ring(bond):
        """Does a breaking bond form a ring with a forming one?"""
        (i, j) = bond.atom_indexes

        for fbond in fbonds:
            for ring in rings:
                # At least one of the forming bond idxs needs to be in the ring
                for fbond_idx in fbond.atom_indexes:
                    if all(idx in ring for idx in (i, j, fbond_idx)):
                        return True
        return False

    # Remove all the breaking bonds that form a ring that also include at
    # least one forming bond
    return fbonds + [bbond for bbond in bbonds if not in_ring(bbond)]


def products_made(species_list, product):
    """Check whether the products are made on the surface

    Arguments:
        species_list (list(autode.species.Species):
        product (autode.species.Species):

    Returns:
        (bool):
    """
    if product is None or product.graph is None:
        logger.warning('Cannot check if products are made')
        return False

    for i, species in enumerate(species_list):
        make_graph(species)

        if is_isomorphic(graph1=species.graph,
                         graph2=product.graph):
            logger.info(f'Products made at point {i}')
            return True

    return False


def peak_idx(species_list):
    """
    Does this list of species contain a peak in the energy?

    Arguments:
        species_list (list(autode.species.Species):

    Returns:
        (bool):
    """
    if any(species.energy is None for species in species_list):
        logger.warning('Cannot determine if path contains a peak, an E=None')
        return None

    for i, species in enumerate(species_list):

        # Cannot be a peak on the end points
        if i == 0 or i == len(species_list) - 1:
            continue

        # Points either side of this species must be lower in energy
        if all(species_list[k].energy < species.energy for k in (i-1, i+1)):
            return i

    return None


def calc_n_images(fbonds, bbonds):
    """
    Calculate the number of images to use in a NEB calculation based on the
    active bonds. Will use a number so the average ∆r between each step on
    each coordinate is ~average_spacing Å

    Arguments:
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):
        species (autode.species.Species):

    Returns:
        (int): Number of images
    """
    logger.info(f'Using a step size of {Config.neb_step_size:.2f} Å')

    differences = [(b.final_dist - b.curr_dist) for b in fbonds + bbonds]
    average_abs_difference = np.average(np.abs(np.array(differences)))

    return int(average_abs_difference / Config.neb_step_size)


def run_final_const_opt(species, method, const_bonds):
    """
    Run a final constrained optimisation on the peak species

    Arguments:
        species (autode.species.Species):
        method (autode.wrappers.ElectronicStructureMethod)
        const_bonds (list(autode.pes.pes.FormingBond)):
    """
    bond_idxs = [bond.atom_indexes for bond in const_bonds]
    opt = Calculation(name=f'{species.name}_peak_const_opt',
                      molecule=species,
                      method=method,
                      n_cores=Config.n_cores,
                      keywords=method.keywords.opt,
                      distance_constraints={bond: species.distance(*bond)
                                            for bond in bond_idxs})
    species.optimise(calc=opt)
    return None

import numpy as np
import autode.exceptions as ex
from autode.config import Config
from autode.log import logger
from autode.calculation import Calculation
from autode.neb.ci import CINEB
from autode.neb.original import highest_peak
from autode.transition_states.ts_guess import get_ts_guess
from autode.utils import work_in
from autode.mol_graphs import find_cycles, is_isomorphic, make_graph
from copy import deepcopy


def get_ts_guess_neb(reactant, product, method, fbonds=None, bbonds=None,
                     name='neb',
                     n=None,
                     generate_final_species=True):
    """
    Get a transition state guess using a nudged elastic band calculation. The
    geometry of the reactant is used as the fixed initial point and the final
    product geometry generated by driving a linear path to products, which is
    used as the initial guess for the NEB images

    Arguments:
        reactant (autode.species.Species):
        product (autode.species.Species):
        method (autode.wrappers.base.ElectronicStructureMethod):

    Keyword Arguments:
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):
        name (str):
        n (int): Number of images to use in the NEB
        generate_final_species (bool):

    Returns:
        (autode.transition_states.ts_guess.TSguess) or None:
    """
    logger.info('Generating a TS guess using a nudged elastic band')

    if generate_final_species and fbonds is not None and bbonds is not None:
        try:
            active_bonds = active_bonds_no_rings(reactant.copy(), fbonds, bbonds)

            species_list = get_interpolated(reactant.copy(), active_bonds,
                                            max_n=calc_n_images(fbonds, bbonds),
                                            method=method,
                                            final_species=product.copy())
        except ex.AtomsNotFound:
            logger.warning('Failed to optimise a point on the linear path')
            return None

        if species_list is None:
            logger.warning('Failed to locate linear path containing a maximum')
            return None

        if len(active_bonds) == 1:
            logger.info('Only explored a single bond should have a very '
                        'good guess of the TS - skipping NEB relaxation')
            return get_ts_guess(species_list[highest_peak(species_list)],
                                reactant, product, name=name)

        neb = CINEB(species_list=species_list)

    # Otherwise using the reactant and product geometries
    else:
        assert n is not None
        neb = CINEB(initial_species=reactant.copy(),
                    final_species=product.copy(),
                    num=n)
        neb.interpolate_geometries()

    # Calculate and generate the TS guess, in a unique directory
    try:
        @work_in(name)
        def calculate():
            return neb.calculate(method=method, n_cores=Config.n_cores)

        calculate()

    except (ex.CouldNotGetProperty, ex.AtomsNotFound):
        logger.error('NEB failed')
        return None

    peak_species = neb.get_species_saddle_point()
    if peak_species is None:
        logger.warning('Found no peak in the NEB')
        return None

    if fbonds is not None and bbonds is not None:
        run_final_const_opt(peak_species, method, const_bonds=fbonds+bbonds)

    return get_ts_guess(peak_species, reactant, product, name=name)


@work_in('NEB_init_path')
def get_interpolated(initial_species, bonds, max_n, method,
                     stop_thresh=0.02, final_species=None):
    """
    Generate the end point on the NEB by running a 1D scan, using by default a
    low-level method. Supprorts using different methods for the starting and
    final (end) points to the method used for the interpolation.
    If method is set then this will be used for both the end and intermediate
     methods

    Arguments:
        initial_species (autode.species.Species):
        bonds (list(autode.pes.pes.ScannedBond)):
        max_n (int): Maximum number of intermediate species to generate between
              the initial and final species
        method (autode.wrappers.base.ElectronicStructureMethod):

    Keyword Arguments:
        stop_thresh (float): Energy threshold in Ha to terminate the
                    interpolation if ∆E between two adjacent points is > this
                    and there is a peak in the surface, return the points.
                    default is ~ 10 kcal mol-1

        final_species (autode.species.Species | None): Final species (e.g.
                      products) on the path that we're interpolating to. If
                      None then isomorphisms are not checked

    Returns:
        (list(autode.species.Species)): Set of intermediate species between
    """
    logger.info('Generating the interpolated species reactant -> product using'
                f' a maximum of {max_n} intermediate points')
    species_set = _get_interp_species_set(max_n, initial_species, bonds,
                                          method, stop_thresh)
    logger.info('Initial interpolation done')

    # Needs to have a maximum in the linear path to have any hope of
    # locating a TS from it
    if highest_peak(species_set) is None:
        if not products_made(species_set, final_species):
            logger.warning('No peak and products not made - failed interp.')
            return None

        # If there is no peak but products have been made then reduce the step
        # size around the region reactants -> products
        spe_l, spe_r = initial_final_missed_peak(species_set,
                                                 product=final_species)
        species_set = divided_species_set(spe_l, spe_r,
                                          bonds=deepcopy(bonds),
                                          method=method)

        if highest_peak(species_set) is None:
            logger.warning('Still no peak from the divided path')
            return None

    # If the final point is higher in energy than the previous then remove
    # the last, then iterate as appropriate
    while len(species_set) >= 2 and species_set[-2].energy < species_set[-1].energy:
        species_set.pop(-1)

    # If only a one bond has been scanned over then the initial path is already
    # pretty good, so truncate to the two points either side of the peak,
    # and the peak
    if len(bonds) == 1:
        logger.info('Truncating interpolated set over the peak')
        idx = highest_peak(species_set)
        species_set = divided_species_set(initial_species=species_set[idx-1],
                                          final_species=species_set[idx+1],
                                          bonds=deepcopy(bonds),
                                          method=method)

    logger.info('Generated initial NEB path')
    return species_set


def initial_final_missed_peak(species_list, product):
    """
    Find guesses of the initial and final species between a missed peak by
    checking that one of the final images is isomorphic to products, if it is
    and reactants are different to product then the missed peak occurs
    between the points where the species are isomorphic to  the initial and
    final points respectively

    Arguments:
        species_list (list(autode.species.Species)):
        product (autode.species.Species):

    Returns:
        (tuple(autode.species.Species, autode.species.Species)):
    """
    assert products_made(species_list, product)

    # Ensure all species have a graph
    for species in species_list:
        make_graph(species)

    def isomorphic_idxs(graph):
        """Return the indexes of the graphs isomorphic to the given"""
        return [i for i, species_ in enumerate(species_list)
                if is_isomorphic(graph1=species_.graph, graph2=graph)]

    # Use the final index that's isomorphic to the initial species (i.e. the
    # first point in the species list)
    idx_l = isomorphic_idxs(graph=species_list[0].graph)[-1]

    # and the right index the first that's isomorphic to the final species
    idx_r = isomorphic_idxs(graph=product.graph)[0]
    logger.info(f'Index {idx_l} was isomorphic to the first point and '
                f'{idx_r} isomorphic to the final species - running a finer '
                f'grid')

    logger.info(f'Dividing {idx_l} -- {idx_r}')
    return species_list[idx_l], species_list[idx_r]


def divided_species_set(initial_species, final_species, bonds, method):
    """
    Divide a list of species

    Arguments:
        initial_species (autode.species.Species):
        bonds (list(autode.pes.pes.ScannedBond)):
        final_species (autode.species.Species): Final species (e.g.
                      products) on the path that we're interpolating to
    Returns:
        (list(autode.species.Species))
    """
    step_size = float(Config.neb_step_size) / 3
    total_deltas = []

    # Set the new initial and final distances on each bond
    for bond in bonds:
        bond.curr_dist = initial_species.distance(*bond)
        bond.final_dist = final_species.distance(*bond)
        # ∆r = r_final - r_initial
        total_deltas.append(bond.final_dist - bond.curr_dist)

    average_abs_difference = np.average(np.abs(np.array(total_deltas)))
    max_n = max(int(average_abs_difference / step_size), 3)

    logger.info(f'Will divide into {max_n} steps, with an average step size '
                f'of {float(Config.neb_step_size) / 3:.3f} Å')

    # max_n rather than max_n - 1 here as we don't need the final point
    deltas = [total_dr / max_n for total_dr in total_deltas]
    species_list = _get_interp_species_set(max_n=max_n,
                                           initial_species=initial_species,
                                           bonds=bonds,
                                           method=method,
                                           deltas=deltas)
    species_list.append(final_species)
    logger.info(f'Divided path into {len(species_list)}')
    return species_list


def _get_interp_species_set(max_n, initial_species, bonds, method,
                            stop_thresh=0.02, deltas=None):
    """
    From an initial species generate a path along a surface defined by
    distance constraints

    Arguments:
        initial_species (autode.species.Species):
        bonds (list(autode.pes.pes.ScannedBond)):
        max_n (int): Maximum number of intermediate species to generate
        method (autode.wrappers.base.ElectronicStructureMethod):
        stop_thresh (float):
        deltas (list(float)): List of ∆r distances for each bond, which will
               be added
    """
    assert max_n > 1

    # Assume there needs to be ∆r_i added max_n times to reach the final
    # distance for each bond i
    if deltas is None:
        deltas = [(b.final_dist - b.curr_dist) / (max_n - 1) for b in bonds]
    else:
        assert len(deltas) == len(bonds)

    consts = {b.atom_indexes: b.curr_dist for b in bonds}

    species_set = []

    # Generate a species with a constrained geometry for each point in the path
    for i in range(max_n):

        if i == 0:
            species = initial_species.copy()

        else:
            species = species_set[i - 1].copy()

            # Add the required change in every bond length to get to the final
            # distances at step n-1
            for j, atom_indexes in enumerate(consts.keys()):
                consts[atom_indexes] += deltas[j]

        # Run the constrained optimisation
        opt = Calculation(name=f'{species.name}_constrained_opt{i}',
                          molecule=species,
                          method=method,
                          keywords=method.keywords.low_opt,
                          n_cores=Config.n_cores,
                          distance_constraints=consts)

        # Set the optimised atoms - can raise AtomsNotFound
        species.optimise(method=method, calc=opt)
        if species.energy is None:
            # To continue there must be final atoms and a final energy
            raise ex.AtomsNotFound

        species_set.append(species)

        # Early stopping if a ~saddle point has already been traversed, must be
        # in the second half of the scan and above an energy threshold for ∆E
        if all((i > 1,
                i > max_n // 2,
                highest_peak(species_set) is not None,
                species.energy - species_set[i - 1].energy > stop_thresh)):
            logger.warning(f'Path contained an energy peak and the point '
                           f'before this one had a lower energy - stopping the'
                           f' interpolation on step {i}')

            return species_set[:-1]

    return species_set


def active_bonds_no_rings(initial_species, fbonds, bbonds):
    """
    From forming and breaking bonds determine which should be used as the
    set of active bonds that define bond constraints. Any breaking bonds that
    form rings with forming bonds or those already in the graph should be
    removed to try and avoid very high energy points in the potential.
    For example:

               H
    forming-> / \  <-breaking
             C--C
               ^
               |
             normal

    by default the breaking bonds final distance will be the current x1.5 or so
    which will push the H too far away (as it's migrating rather than leaving).
    A much better strategy is to only scan the forming C-H bond and leave the
    breaking bond to do it's own thing.

    Arguments:
        initial_species (autode.species.Species):
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):

    Returns:
        (list(autode.pes.pes.ScannedBond)):
    """
    logger.info('Removing breaking bonds that are also in the set of forming '
                'bonds')

    if len(fbonds) == 0:
        logger.info('No need to check for rings, no forming bonds')
        return bbonds

    graph = initial_species.graph.copy()

    # Add all the active bonds if they don't already exist
    for bond in bbonds + fbonds:
        if bond.atom_indexes not in graph.edges:
            graph.add_edge(*bond.atom_indexes)

    # Find the rings in this molecular graph
    rings = find_cycles(graph)

    def in_ring(bond):
        """Does a breaking bond form a ring with a forming one?"""
        (i, j) = bond.atom_indexes

        for fbond in fbonds:
            for ring in rings:
                # At least one of the forming bond idxs needs to be in the ring
                for fbond_idx in fbond.atom_indexes:
                    if all(idx in ring for idx in (i, j, fbond_idx)):
                        return True
        return False

    # Remove all the breaking bonds that form a ring that also include at
    # least one forming bond
    return fbonds + [bbond for bbond in bbonds if not in_ring(bbond)]


def products_made(species_list, product):
    """Check whether the products are made on the surface

    Arguments:
        species_list (list(autode.species.Species):
        product (autode.species.Species):

    Returns:
        (bool):
    """
    if product is None or product.graph is None:
        logger.warning('Cannot check if products are made')
        return False

    for i, species in enumerate(species_list):
        make_graph(species)

        if is_isomorphic(graph1=species.graph,
                         graph2=product.graph):
            logger.info(f'Products made at point {i}')
            return True

    return False


def calc_n_images(fbonds, bbonds):
    """
    Calculate the number of images to use in a NEB calculation based on the
    active bonds. Will use a number so the average ∆r between each step on
    each coordinate is ~average_spacing Å

    Arguments:
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):

    Returns:
        (int): Number of images
    """
    logger.info(f'Using a step size of {Config.neb_step_size:.2f} Å')

    differences = [(b.final_dist - b.curr_dist) for b in fbonds + bbonds]
    average_abs_difference = np.average(np.abs(np.array(differences)))

    return max(int(average_abs_difference / Config.neb_step_size), 3)


def run_final_const_opt(species, method, const_bonds):
    """
    Run a final constrained optimisation on the peak species

    Arguments:
        species (autode.species.Species):
        method (autode.wrappers.ElectronicStructureMethod)
        const_bonds (list(autode.pes.pes.FormingBond)):
    """
    bond_idxs = [bond.atom_indexes for bond in const_bonds]
    opt = Calculation(name=f'{species.name}_peak_const_opt',
                      molecule=species,
                      method=method,
                      n_cores=Config.n_cores,
                      keywords=method.keywords.opt,
                      distance_constraints={bond: species.distance(*bond)
                                            for bond in bond_idxs})
    species.optimise(calc=opt)
    return None

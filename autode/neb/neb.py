import numpy as np
import autode.exceptions as ex
from autode.config import Config
from autode.log import logger
from autode.calculation import Calculation
from autode.neb.ci import CINEB
from autode.neb.initial_path import InitialPath
from autode.transition_states.ts_guess import get_ts_guess
from autode.utils import work_in
from autode.mol_graphs import find_cycles, is_isomorphic, make_graph
from copy import deepcopy


def get_ts_guess_neb(reactant, product, method, fbonds=None, bbonds=None,
                     name='neb',
                     n=None,
                     generate_final_species=True):
    """
    Get a transition state guess using a nudged elastic band calculation. The
    geometry of the reactant is used as the fixed initial point and the final
    product geometry generated by driving a linear path to products, which is
    used as the initial guess for the NEB images

    Arguments:
        reactant (autode.species.Species):
        product (autode.species.Species):
        method (autode.wrappers.base.ElectronicStructureMethod):

    Keyword Arguments:
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):
        name (str):
        n (int): Number of images to use in the NEB
        generate_final_species (bool):

    Returns:
        (autode.transition_states.ts_guess.TSguess) or None:
    """
    logger.info('Generating a TS guess using a nudged elastic band')

    if generate_final_species and fbonds is not None and bbonds is not None:
        try:
            active_bonds = active_bonds_no_rings(reactant.copy(), fbonds, bbonds)

            path = InitialPath(init_species=reactant.copy(),
                               bonds=active_bonds,
                               method=method)

            path.generate()
            if path.peak_idx is None:
                logger.warning('No peak in the initial path')
                return None

            return get_ts_guess(path[path.peak_idx].species,
                                reactant, product, name=name)



















            path = get_interpolated(initial_species=reactant.copy(),
                                            bonds=active_bonds,
                                            max_n=calc_n_images(fbonds, bbonds),
                                            method=method,
                                            final_species=product.copy())
            path.truncate_final_points()

        except ex.AtomsNotFound:
            logger.warning('Failed to optimise a point on the linear path')
            return None

        if path is None:
            logger.warning('Failed to locate linear path containing a maximum')
            return None

        if len(active_bonds) == 1:
            logger.info('Only explored a single bond should have a very '
                        'good guess of the TS - skipping NEB relaxation')
            return get_ts_guess(path[path.peak_idx],
                                reactant, product, name=name)

        neb = CINEB(species_list=path)

    # Otherwise using the reactant and product geometries
    else:
        assert n is not None
        neb = CINEB(initial_species=reactant.copy(),
                    final_species=product.copy(),
                    num=n)
        neb.interpolate_geometries()

    # Calculate and generate the TS guess, in a unique directory
    try:
        @work_in(name)
        def calculate():
            return neb.calculate(method=method, n_cores=Config.n_cores)

        calculate()

    except (ex.CouldNotGetProperty, ex.AtomsNotFound):
        logger.error('NEB failed')
        return None

    peak_species = neb.get_species_saddle_point()
    if peak_species is None:
        logger.warning('Found no peak in the NEB')
        return None

    if fbonds is not None and bbonds is not None:
        run_final_const_opt(peak_species, method, const_bonds=fbonds+bbonds)

    return get_ts_guess(peak_species, reactant, product, name=name)


def initial_final_missed_peak(species_list, product):
    """
    Find guesses of the initial and final species between a missed peak by
    checking that one of the final images is isomorphic to products, if it is
    and reactants are different to product then the missed peak occurs
    between the points where the species are isomorphic to  the initial and
    final points respectively

    Arguments:
        species_list (list(autode.species.Species)):
        product (autode.species.Species):

    Returns:
        (tuple(autode.species.Species, autode.species.Species)):
    """
    assert species_list.products_made(product)

    # Ensure all species have a graph
    for species in species_list:
        make_graph(species)

    def isomorphic_idxs(graph):
        """Return the indexes of the graphs isomorphic to the given"""
        return [i for i, species_ in enumerate(species_list)
                if is_isomorphic(graph1=species_.graph, graph2=graph)]

    # Use the final index that's isomorphic to the initial species (i.e. the
    # first point in the species list)
    idx_l = isomorphic_idxs(graph=species_list[0].graph)[-1]

    # and the right index the first that's isomorphic to the final species
    idx_r = isomorphic_idxs(graph=product.graph)[0]
    logger.info(f'Index {idx_l} was isomorphic to the first point and '
                f'{idx_r} isomorphic to the final species - running a finer '
                f'grid')

    logger.info(f'Dividing {idx_l} -- {idx_r}')
    return species_list[idx_l], species_list[idx_r]


def active_bonds_no_rings(initial_species, fbonds, bbonds):
    """
    From forming and breaking bonds determine which should be used as the
    set of active bonds that define bond constraints. Any breaking bonds that
    form rings with forming bonds or those already in the graph should be
    removed to try and avoid very high energy points in the potential.
    For example:

               H
    forming-> / \  <-breaking
             C--C
               ^
               |
             normal

    by default the breaking bonds final distance will be the current x1.5 or so
    which will push the H too far away (as it's migrating rather than leaving).
    A much better strategy is to only scan the forming C-H bond and leave the
    breaking bond to do it's own thing.

    Arguments:
        initial_species (autode.species.Species):
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):

    Returns:
        (list(autode.pes.pes.ScannedBond)):
    """
    logger.info('Removing breaking bonds that are also in the set of forming '
                'bonds')

    if len(fbonds) == 0:
        logger.info('No need to check for rings, no forming bonds')
        return bbonds

    graph = initial_species.graph.copy()

    # Add all the active bonds if they don't already exist
    for bond in bbonds + fbonds:
        if bond.atom_indexes not in graph.edges:
            graph.add_edge(*bond.atom_indexes)

    # Find the rings in this molecular graph
    rings = find_cycles(graph)

    def in_ring(bond):
        """Does a breaking bond form a ring with a forming one?"""
        (i, j) = bond.atom_indexes

        for fbond in fbonds:
            for ring in rings:
                # At least one of the forming bond idxs needs to be in the ring
                for fbond_idx in fbond.atom_indexes:
                    if all(idx in ring for idx in (i, j, fbond_idx)):
                        return True
        return False

    # Remove all the breaking bonds that form a ring that also include at
    # least one forming bond
    return fbonds + [bbond for bbond in bbonds if not in_ring(bbond)]








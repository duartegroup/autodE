import autode.exceptions as ex
from autode.config import Config
from autode.log import logger
from autode.calculation import Calculation
from autode.neb.ci import CINEB
from autode.methods import get_lmethod
from autode.transition_states.ts_guess import get_ts_guess
from autode.utils import work_in
from autode.mol_graphs import find_cycles
import numpy as np


def get_ts_guess_neb(reactant, product, method, fbonds=None, bbonds=None,
                     name='neb',
                     n=None,
                     generate_final_species=True):
    """
    Get a transition state guess using a nudged elastic band calculation. The
    geometry of the reactant is used as the fixed initial point and the final
    product geometry generated by driving a linear path to products, which is
    used as the initial guess for the NEB images

    Arguments:
        reactant (autode.species.Species):
        product (autode.species.Species):
        method (autode.wrappers.base.ElectronicStructureMethod):

    Keyword Arguments:
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):
        name (str):
        n (int): Number of images to use in the NEB
        generate_final_species (bool):

    Returns:
        (autode.transition_states.ts_guess.TSguess) or None:
    """
    logger.info('Generating a TS guess using a nudged elastic band')

    if generate_final_species and fbonds is not None and bbonds is not None:

        try:
            species_list = get_interpolated(reactant, fbonds, bbonds,
                                            max_n=calc_n_images(fbonds, bbonds),
                                            method=method)
        except ex.AtomsNotFound:
            logger.warning('Failed to optimise a point on the linear path')
            return None

        if species_list is None:
            logger.warning('Failed to locate linear path containing a maximum')
            return None

        neb = CINEB(species_list=species_list)
        # neb.partition(n=2)

    # Otherwise using the reactant and product geometries
    else:
        assert n is not None
        neb = CINEB(initial_species=reactant.copy(),
                    final_species=product.copy(),
                    num=n)
        neb.interpolate_geometries()

    # Calculate and generate the TS guess, in a unique directory
    try:
        @work_in(name)
        def calculate():
            return neb.calculate(method=method, n_cores=Config.n_cores)

        calculate()

    except ex.CouldNotGetProperty:
        logger.error('NEB failed')
        return None

    return get_ts_guess(neb.get_species_saddle_point(),
                        reactant, product, name=name)


@work_in('NEB_init_path')
def get_interpolated(initial_species, fbonds, bbonds, max_n, method=None,
                     stop_thresh=0.02):
    """
    Generate the end point on the NEB by running a 1D scan, using by default a
    low-level method. Supprorts using different methods for the starting and
    final (end) points to the method used for the interpolation.
    If method is set then this will be used for both the end and intermediate
     methods

    Arguments:
        initial_species (autode.species.Species):
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):
        max_n (int): Maximum number of intermediate species to generate between
              the initial and final species

    Keyword Arguments:
        method (autode.wrappers.base.ElectronicStructureMethod):
        stop_thresh (float): Energy threshold in Ha to terminate the
                    interpolation if ∆E between two adjacent points is > this
                    and there is a peak in the surface, return the points.
                    default is ~ 10 kcal mol-1

    Returns:
        (list(autode.species.Species)): Set of intermediate species between
    """
    assert fbonds is not None and bbonds is not None
    logger.info('Generating the interpolated species reactant -> product using'
                f' a maximum of {max_n} intermediate points')

    bonds = active_bonds_no_rings(initial_species, fbonds, bbonds)

    # Calculate the uniform change in each bond distance from initial -> final
    deltas = [(b.final_dist - b.curr_dist)/(max_n-1) for b in bonds]

    # Set a dictionary of bond length constraints
    consts = {b.atom_indexes: b.curr_dist for b in bonds}

    species_set = []

    # Generate a species with a constrained geometry for each point in the path
    for i in range(max_n):

        if i == 0:
            species = initial_species.copy()

        else:
            species = species_set[i-1].copy()

            # Add the required change in every bond length to get to the final
            # distances at step n-1
            for j, atom_indexes in enumerate(consts.keys()):
                consts[atom_indexes] += deltas[j]

        # Run the constrained optimisation
        if method is None:
            method = get_lmethod()

        opt = Calculation(name=f'{species.name}_constrained_opt{i}',
                          molecule=species,
                          method=method,
                          keywords=method.keywords.opt,
                          n_cores=Config.n_cores,
                          distance_constraints=consts)

        # Set the optimised atoms - can raise AtomsNotFound
        species.optimise(method=method, calc=opt)
        if species.energy is None:
            # To continue there must be final atoms and a final energy
            raise ex.AtomsNotFound

        species_set.append(species)

        # Early stopping if a ~saddle point has already been traversed, must be
        # in the second half of the scan and above an energy threshold for ∆E
        if all((i > 1,
                i > max_n//2,
                contains_peak(species_set),
                species.energy - species_set[i-1].energy > stop_thresh)):

            logger.warning(f'Path contained an energy peak and the point '
                           f'before this one had a lower energy - stopping the'
                           f' interpolation on step {i}')

            return species_set[:-1]

    if not contains_peak(species_set):
        # Needs to have a maximum in the linear path to have any hope of
        # locating a TS from it
        return None

    # If the final point is higher in energy than the previous then remove
    # the last, then iterate as appropriate
    while len(species_set) >= 2 and species_set[-2].energy < species_set[-1].energy:
        species_set.pop(-1)

    logger.info('Generated initial NEB path')
    return species_set


def active_bonds_no_rings(initial_species, fbonds, bbonds):
    """
    From forming and breaking bonds determine which should be used as the
    set of active bonds that define bond constraints. Any breaking bonds that
    form rings with forming bonds or those already in the graphshould be
    removed to try and avoid very high energy points in the potential.
    For example:

               H
    forming-> / \  <-breaking
             C--C
               ^
               |
             normal

    by default the breaking bonds final distance will be the current x1.5 or so
    which will push the H too far away (as it's migrating rather than leaving).
    A much better strategy is to only scan the forming C-H bond and leave the
    breaking bond to do it's own thing.

    Arguments:
        initial_species (autode.species.Species):
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):

    Returns:
        (list(autode.pes.pes.ScannedBond)):
    """
    logger.info('Removing breaking bonds that are also in the set of forming '
                'bonds')

    graph = initial_species.graph.copy()

    # Add all the active bonds if they don't already exist
    for bond in bbonds + fbonds:
        if bond.atom_indexes not in graph.edges:
            graph.add_edge(*bond.atom_indexes)

    # Find the rings in this molecular graph
    rings = find_cycles(graph)

    def in_ring(bond):
        (i, j) = bond.atom_indexes

        for ring in rings:
            if all(idx in ring for idx in (i, j)):
                return True

        return False

    # Remove all the breaking bonds that form a ring that also include at
    # least one forming bond
    return fbonds + [bbond for bbond in bbonds if not in_ring(bbond)]


def contains_peak(species_list):
    """
    Does this list of species contain a peak in the energy?

    Arguments:
        species_list (list(autode.species.Species):

    Returns:
        (bool):
    """
    if any(species.energy is None for species in species_list):
        logger.warning('Cannot determine if path contains a peak, an E=None')
        return False

    for i, species in enumerate(species_list):

        # Cannot be a peak on the end points
        if i == 0 or i == len(species_list) - 1:
            continue

        # Points either side of this species must be lower in energy
        if all(species_list[k].energy < species.energy for k in (i-1, i+1)):
            return True

    return False


def calc_n_images(fbonds, bbonds, average_spacing=0.2):
    """
    Calculate the number of images to use in a NEB calculation based on the
    active bonds. Will use a number so the average ∆r between each step on
    each coordinate is ~average_spacing Å

    Arguments:
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):

    Keyword Arguments:
        average_spacing (float):

    Returns:
        (int): Number of images
    """
    differences = [(b.final_dist - b.curr_dist) for b in fbonds + bbonds]
    average_abs_difference = np.average(np.abs(np.array(differences)))

    return int(average_abs_difference / average_spacing)

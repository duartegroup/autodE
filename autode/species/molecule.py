import re
import rdkit
from typing import Optional, Union, List
from multiprocessing import Pool
from rdkit.Chem import AllChem
from autode.log.methods import methods
from autode.input_output import xyz_file_to_atoms
from autode.conformers.conformer import Conformer
from autode.conformers.conf_gen import get_simanl_conformer
from autode.conformers.conformers import atoms_from_rdkit_mol
from autode.atoms import metals
from autode.config import Config
from autode.log import logger
from autode.mol_graphs import make_graph
from autode.smiles.smiles import init_organic_smiles
from autode.smiles.smiles import init_smiles
from autode.species.species import Species
from autode.utils import requires_atoms


class Molecule(Species):

    def __init__(self,
                 name:         str = 'molecule',
                 smiles:       Optional[str] = None,
                 atoms:        Union['autode.atoms.Atoms',
                                     List['autode.atoms.Atom'],
                                     None] = None,
                 solvent_name: Optional[str] = None,
                 charge:       int = 0,
                 mult:         int = 1):
        """
        A molecular species constructable from SMILES or a set of atoms,
        has default charge and spin multiplicity.

        Keyword Arguments:
            name (str): Name of the molecule or a .xyz filename

            smiles (str): Standard SMILES string. e.g. generated by
                          Chemdraw

            atoms (list(autode.atoms.Atom)): List of atoms in the species

            solvent_name (str): Solvent that the molecule is immersed in

            charge (int): Charge on the molecule. Default = 0

            mult (int): Spin multiplicity on the molecule. Default = 1
        """
        logger.info(f'Generating a Molecule object for {name}')
        super().__init__(name, atoms, charge, mult, solvent_name)

        if name.endswith('.xyz'):
            self._init_xyz_file(xyz_filename=name)

        self.smiles = smiles
        self.rdkit_mol_obj = None
        self.rdkit_conf_gen_is_fine = True

        if smiles is not None:
            self._init_smiles(smiles)

        elif atoms is not None:
            make_graph(self)

        # If the name is unassigned use a more interpretable chemical formula
        if name == 'molecule' and self.atoms is not None:
            self.name = self.formula

    def __repr__(self):
        return self._repr(prefix='Molecule')

    def _init_smiles(self, smiles: str):
        """Initialise a molecule from a SMILES string using RDKit if it's
        purely organic.

        Arguments:
            smiles (str):
        """
        at_strings = re.findall(r'\[.*?]', smiles)

        if any(metal in string for metal in metals for string in at_strings):
            init_smiles(self, smiles)

        else:
            init_organic_smiles(self, smiles)

        logger.info(f'Initialisation with SMILES successful. '
                    f'Charge={self.charge}, Multiplicity={self.mult}, '
                    f'Num. Atoms={self.n_atoms}')
        return None

    def _init_xyz_file(self, xyz_filename: str):
        """
        Initialise a molecule from a .xyz file

        Arguments:
            xyz_filename (str):

        Raises:
            (ValueError)
        """
        logger.info('Generating species from .xyz file')

        self.atoms = xyz_file_to_atoms(xyz_filename)

        if (sum(atom.atomic_number for atom in self.atoms) % 2 != 0
            and self.charge % 2 == 0 and self.mult == 1):
            raise ValueError('Initialised a molecule from an xyz file with  '
                             'an odd number of electrons but had an even '
                             'charge and 2S + 1 = 1. Impossible!')

        # Override the default name with something more descriptive
        if self.name == 'molecule' or self.name.endswith('.xyz'):
            self.name = xyz_filename.rstrip('.xyz')

        make_graph(self)
        return None

    @requires_atoms
    def _generate_conformers(self,
                             n_confs: Optional[int] = None):
        """
        Use a simulated annealing approach to generate conformers for this
        molecule.

        Keyword Arguments:
            n_confs (int): Number of conformers requested if None default to
                           autode.Config.num_conformers
        """

        n_confs = n_confs if n_confs is not None else Config.num_conformers
        self.conformers.clear()

        if self.smiles is not None and self.rdkit_conf_gen_is_fine:
            logger.info(f'Using RDKit to gen conformers. {n_confs} requested')

            m_string = 'ETKDGv3' if hasattr(AllChem, 'ETKDGv3') else 'ETKDGv2'
            logger.info(f'Using the {m_string} method')

            method_class = getattr(AllChem, m_string)
            method = method_class()
            method.pruneRmsThresh = Config.rmsd_threshold
            method.numThreads = Config.n_cores
            method.useSmallRingTorsion = True

            logger.info('Running conformation generation with RDKit... running')
            conf_ids = list(AllChem.EmbedMultipleConfs(self.rdkit_mol_obj,
                                                       numConfs=n_confs,
                                                       params=method))
            logger.info('                                          ... done')

            for conf_id in conf_ids:
                conf = Conformer(species=self, name=f'{self.name}_conf{conf_id}')
                conf.atoms = atoms_from_rdkit_mol(self.rdkit_mol_obj, conf_id)
                self.conformers.append(conf)

            methods.add(f'{m_string} algorithm (10.1021/acs.jcim.5b00654) '
                        f'implemented in RDKit v. {rdkit.__version__}')

        else:
            logger.info('Using repulsion+relaxed (RR) to generate conformers')
            with Pool(processes=Config.n_cores) as pool:
                results = [pool.apply_async(get_simanl_conformer, (self, None, i))
                           for i in range(n_confs)]
                self.conformers = [res.get(timeout=None) for res in results]

            self.conformers.prune_on_energy(e_tol=1E-10)
            methods.add('RR algorithm (???) implemented in autodE')

        self.conformers.prune_on_rmsd()
        return None

    def populate_conformers(self, n_confs: int):
        """
        Populate self.conformers with a conformers generated using a default
        method

        Arguments:
            n_confs (int): Number of conformers to try and generate
        """
        return self._generate_conformers(n_confs=n_confs)


class Reactant(Molecule):
    """Reactant molecule"""

    def to_product(self):
        """
        Generate a copy of this reactant as a product

        Returns:
            (autode.species.molecule.Product): Product
        """
        product = self.copy()
        product.__class__ = Product

        return product


class Product(Molecule):
    """Product molecule"""

    def to_reactant(self):
        """
        Generate a copy of this product as a reactant

        Returns:
            (autode.species.molecule.Product): Product
        """
        reactant = self.copy()
        reactant.__class__ = Reactant

        return reactant
